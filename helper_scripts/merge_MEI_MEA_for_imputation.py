#!/usr/bin/env python

'''
Copyright (c) 2020 RIKEN
All Rights Reserved
See file LICENSE for details.

Prerequisite:
Python3.7.

Usage: python %prog -i joint_call_MEI.vcf(.gz) -a joint_call_MEA.vcf(.gz) -n cohort_name

Usage details:
This script merged two VCF files: VCF of MEIs and VCF of absent MEs. The input VCF files must be the joint call, which can be generated by joint call pipeline of MEGAnE. This script cannot merge individual-level VCF files.
This script not only merges two VCF, but also removes multi-allelic MEs. When removing multi-allelic MEs, this script keeps one with highest AF, and discards the other MEs.
This script can take gzip-ed VCF files.

Outputs:
This script outputs four files below:
- input_MEI_biallelic_PASS.vcf.gz           : This contains biallelic MEIs which passed the filter.
- input_MEA_biallelic_PASS.vcf.gz           : This contains biallelic absent MEs which passed the filter.
- cohort_name_biallelic_PASS.vcf.gz         : This is the main output. This contains biallelic polymorphic MEs which passed the filter. This file can be used for imputation.
- cohort_name_multiallelic_ME_summary.txt   : This contains summary of multi-allelic MEs.

Show help message:
python %prog -h
'''


import os,sys,glob,gzip,argparse
import collections


parser=argparse.ArgumentParser(description='')
parser.add_argument('-i', metavar='str', type=str, help='Required. Specify output file from samtools coverage.')
parser.add_argument('-a', metavar='str', type=str, help='Required. Specify a file containing autosomes. Default=/path/to/prog/lib/human_autosomes_ucsc_style.txt')
parser.add_argument('-n', metavar='str', type=str, help='Optional. Specify output file name. Otherwise, output result as stdout.')
args=parser.parse_args()

ins=args.i
abs=args.a
cohort=args.n


# file check
for f in (ins, abs):
    if f is None:
        print('Error: You need to specify input file with "-i" option.')
        exit(1)
    else:
        if os.path.exists(f) is not True:
            print('Error: Input file does not exist.')
            exit(1)


if not '.vcf' in ins:
    print('please specify .vcf file', file=sys.stderr)
    exit(1)
if not '.vcf' in abs:
    print('please specify .vcf file', file=sys.stderr)
    exit(1)


def resolve_overlap_in_a_vcf(f):
    outfname_base=os.path.basename(f).rsplit('.vcf', 1)[0]
    out_nonoverlap='%s_biallelic_PASS.vcf.gz' % outfname_base
    
    # resolve overlap
    if f[-7:] == '.vcf.gz' or f[-8:] == '.vcf.bgz':
        infile=gzip.open(f)
        gzip_judge=True
    elif f[-4:] == '.vcf':
        infile=open(f)
        gzip_judge=False
    else:
        print('please specify .vcf file', file=sys.stderr)
        exit(1)
    
    d={}
    for line in infile:
        if gzip_judge is True:
            line=line.decode()
        if not line[0] == '#':
            ls=line.split('\t', 10)
            if ls[6] == 'PASS':
                if not ls[0] in d:
                    d[ls[0]]=collections.Counter()
                d[ls[0]][int(ls[1])] += 1

    hits={}
    overlap_ins_ins=0
    for chr in d:
        for pos in d[chr]:
            if d[chr][pos] >= 2:
                if not chr in hits:
                    hits[chr]=set()
                hits[chr].add(str(pos))
                overlap_ins_ins += d[chr][pos]

    if overlap_ins_ins >= 1:
        print('Multi-allelic ME in %s detected, n = %d' % (f, overlap_ins_ins))
        summary_out.append('Multi-allelic ME in %s detected, n = %d\n' % (f, overlap_ins_ins))
        
        infile.seek(0)
        hits_lines={}
        for chr in hits:
            hits_lines[chr]={}
            for pos in hits[chr]:
                hits_lines[chr][pos]=[]
        for line in infile:
            if gzip_judge is True:
                line=line.decode()
            if not line[0] == '#':
                ls=line.split('\t', 10)
                if ls[6] == 'PASS':
                    if ls[0] in hits:
                        if ls[1] in hits[ls[0]]:
                            hits_lines[ls[0]][ls[1]].append(line)
        
        keep={}
        for chr in hits:
            keep[chr]={}
            for pos in hits[chr]:
                keep[chr][pos]=[]
        
        for chr in hits_lines:
            for pos in hits_lines[chr]:
                acs=[]
                for line in hits_lines[chr][pos]:
                    ls=line.split('\t', 10)
                    for info in ls[7].split(';')[::-1]:
                        if 'AC=' in info:
                            ac=int(info.replace('AC=', ''))
                            break
                    acs.append([ac, line, ls[2]])
                acs=sorted(acs)
                keep[chr][pos]=acs[-1][1]
                outchar=[]
                outchar.append('keep=%s,%d' % (acs[-1][2], acs[-1][0]))
                for ac,_,id in acs[:-1]:
                    outchar.append('discard=%s,%d' % (id, ac))
                outchar=';'.join(outchar) +'\n'
                summary_out.append(outchar)
                
        infile.seek(0)
        outfile=gzip.open(out_nonoverlap, 'wt')
        for line in infile:
            if gzip_judge is True:
                line=line.decode()
            if not line[0] == '#':
                ls=line.split('\t', 10)
                if ls[6] == 'PASS':
                    if ls[0] in keep:
                        if ls[1] in keep[ls[0]]:
                            if len(keep[ls[0]][ls[1]]) > 0:
                                outfile.write(keep[ls[0]][ls[1]])
                                keep[ls[0]][ls[1]]=''
                        else:
                            outfile.write(line)
                    else:
                        outfile.write(line)
            else:
                outfile.write(line)
        infile.close()
        outfile.close()
    else:
        print('Multi-allelic ME in %s was not detected.' % f)
        summary_out.append('Multi-allelic ME in %s was not detected.' % f)
        
        infile.seek(0)
        outfile=gzip.open(out_nonoverlap, 'wt')
        for line in infile:
            if gzip_judge is True:
                line=line.decode()
            if not line[0] == '#':
                ls=line.split('\t', 10)
                if ls[6] == 'PASS':
                    outfile.write(line)
            else:
                outfile.write(line)
        infile.close()
        outfile.close()
    summary_out.append('\n')
    return out_nonoverlap


def resolve_overlap_between_vcf_vcf(ins, abs, cohort):
    out_nonoverlap='%s_biallelic_PASS.vcf.gz' % cohort
    
    # resolve overlap
    f=ins
    if f[-7:] == '.vcf.gz' or f[-8:] == '.vcf.bgz':
        insfile=gzip.open(f)
        gzip_judge=True
    else:
        insfile=open(f)
        gzip_judge=False
    
    f=abs
    if f[-7:] == '.vcf.gz' or f[-8:] == '.vcf.bgz':
        absfile=gzip.open(f)
        gzip_judge=True
    else:
        absfile=open(f)
        gzip_judge=False
    
    d={}
    for line in insfile:
        if gzip_judge is True:
            line=line.decode()
        if not line[0] == '#':
            ls=line.split('\t', 10)
            if ls[6] == 'PASS':
                if not ls[0] in d:
                    d[ls[0]]=collections.Counter()
                d[ls[0]][int(ls[1])] += 1
    for line in absfile:
        if gzip_judge is True:
            line=line.decode()
        if not line[0] == '#':
            ls=line.split('\t', 10)
            if ls[6] == 'PASS':
                if not ls[0] in d:
                    d[ls[0]]=collections.Counter()
                d[ls[0]][int(ls[1])] += 1
    
    hits={}
    overlap_ins_abs=0
    for chr in d:
        for pos in d[chr]:
            if d[chr][pos] >= 2:
                if not chr in hits:
                    hits[chr]=set()
                hits[chr].add(str(pos))
                overlap_ins_abs += d[chr][pos]
    
    if overlap_ins_abs >= 1:
        print('Multi-allelic ME between %s and %s detected, n = %d' % (ins, abs, overlap_ins_abs))
        summary_out.append('Multi-allelic ME between %s and %s detected, n = %d\n' % (ins, abs, overlap_ins_abs))
        
        insfile.seek(0)
        absfile.seek(0)
        hits_lines={}
        for chr in hits:
            hits_lines[chr]={}
            for pos in hits[chr]:
                hits_lines[chr][pos]=[]
        for line in insfile:
            if gzip_judge is True:
                line=line.decode()
            if not line[0] == '#':
                ls=line.split('\t', 10)
                if ls[6] == 'PASS':
                    if ls[0] in hits:
                        if ls[1] in hits[ls[0]]:
                            hits_lines[ls[0]][ls[1]].append(line)
        for line in absfile:
            if gzip_judge is True:
                line=line.decode()
            if not line[0] == '#':
                ls=line.split('\t', 10)
                if ls[6] == 'PASS':
                    if ls[0] in hits:
                        if ls[1] in hits[ls[0]]:
                            hits_lines[ls[0]][ls[1]].append(line)

        keep={}
        for chr in hits:
            keep[chr]={}
            for pos in hits[chr]:
                keep[chr][pos]=[]
        
        for chr in hits_lines:
            for pos in hits_lines[chr]:
                acs=[]
                for line in hits_lines[chr][pos]:
                    ls=line.split('\t', 10)
                    for info in ls[7].split(';')[::-1]:
                        if 'AC=' in info:
                            ac=int(info.replace('AC=', ''))
                            break
                    acs.append([ac, line, ls[2]])
                acs=sorted(acs)
                keep[chr][pos]=acs[-1][1]
                outchar=[]
                outchar.append('keep=%s,%d' % (acs[-1][2], acs[-1][0]))
                for ac,_,id in acs[:-1]:
                    outchar.append('discard=%s,%d' % (id, ac))
                outchar=';'.join(outchar) +'\n'
                summary_out.append(outchar)
                
        insfile.seek(0)
        absfile.seek(0)
        outfile=gzip.open(out_nonoverlap, 'wt')
        for line in insfile:
            if gzip_judge is True:
                line=line.decode()
            if not line[0] == '#':
                ls=line.split('\t', 10)
                if ls[6] == 'PASS':
                    if ls[0] in keep:
                        if ls[1] in keep[ls[0]]:
                            if ls[2] in keep[ls[0]][ls[1]]:
                                outfile.write(keep[ls[0]][ls[1]])
                        else:
                            outfile.write(line)
                    else:
                        outfile.write(line)
            else:
                outfile.write(line)
        for line in absfile:
            if gzip_judge is True:
                line=line.decode()
            if not line[0] == '#':
                ls=line.split('\t', 10)
                if ls[6] == 'PASS':
                    if ls[0] in keep:
                        if ls[1] in keep[ls[0]]:
                            if ls[2] in keep[ls[0]][ls[1]]:
                                outfile.write(keep[ls[0]][ls[1]])
                        else:
                            outfile.write(line)
                    else:
                        outfile.write(line)
        insfile.close()
        absfile.close()
        outfile.close()
    else:
        print('Multi-allelic ME between %s and %s was not detected.' % (ins, abs))
        summary_out.append('Multi-allelic ME between %s and %s was not detected.\n' % (ins, abs))
        
        insfile.seek(0)
        absfile.seek(0)
        outfile=gzip.open(out_nonoverlap, 'wt')
        for line in insfile:
            if gzip_judge is True:
                line=line.decode()
            if not line[0] == '#':
                ls=line.split('\t', 10)
                if ls[6] == 'PASS':
                    outfile.write(line)
            else:
                outfile.write(line)
        for line in insfile:
            if gzip_judge is True:
                line=line.decode()
            if not line[0] == '#':
                ls=line.split('\t', 10)
                if ls[6] == 'PASS':
                    outfile.write(line)
        insfile.close()
        absfile.close()
        outfile.close()
    summary_out.append('\n')
    return out_nonoverlap


# main
summary_out=[]

ins_nonoverlap=resolve_overlap_in_a_vcf(ins)
abs_nonoverlap=resolve_overlap_in_a_vcf(abs)
final_outf=resolve_overlap_between_vcf_vcf(ins_nonoverlap, abs_nonoverlap, cohort)

summary_out.append('Multi-allelic ME removal finished. Please see: %s' % final_outf)

with open('%s_multiallelic_ME_summary.txt' % cohort, 'w') as outfile:
    outfile.write(''.join(summary_out))

print('\nMulti-allelic ME removal finished. Please see: %s' % final_outf)


