/*
 Author: Shohei Kojima @ RIKEN
 Description:
    This reads a fasta file and removes sequences
    that are highly likely multi-mapping in target genome.
    This script takes output files from `save_redundant_kmers`.
 Compile:
    g++ -o remove_multimapping_reads_from_fa remove_multimapping_reads_from_fa.cpp -O2
    g++ -shared -fPIC -o remove_multimapping_reads_from_fa.so remove_multimapping_reads_from_fa.cpp -O2
 Usage:
    ./prog input_prefix input.fa output.fa
    (input_prefix should be the `output_prefix` specified when running `save_redundant_kmers`)
 Output:
    1) output.fa : this only contains that are not likely multi-mapping in the human genome.
 Misc info:
    This only uses one thread.
    In the case of GRCh38, this requires ~4 GB RAM.
 */

#include <fstream>
#include <iostream>
#include <unistd.h>
#include <vector>
#include <cassert>
#include <algorithm>
#include "dna_to_2bit.hpp"
#include "remove_multimapping_reads_from_fa.hpp"
using namespace dna_to_2bit_hpp;

typedef unsigned long long ull;
const char FASTA_HEADER_START = '>';
const int  MAX_READ_LEN = 512;



/*
 This is a custom binary search similar to std::lower_bound
 */
inline ull custom_binary_search(const std::vector<uint64_t> &vec, ull &vec_size, uint64_t &key) {
    if (vec[vec_size-1] < key) {
        return vec_size;
    }
    ull step= 1 << (63 - __builtin_clz(vec_size-1));
    ull pos= vec[step - 1] < key ? vec_size - step - 1 : -1;
    while ((step >>= 1) > 0) {
        pos= (vec[pos + step] < key ? pos + step : pos);
    }
    return pos + 1;
}


/*
 This converts 32-nt DNA to 2bit and stores as uint64_t in an array.
 Args:
    1) pointer to seq
    2) seq len (ull)
    3) window_size (must be 32)
    4) vector to store the 2bit seq
 */
inline int dna_to_2bit_monodirectional_64(const char* seq, ull& seqlen, const int& window_size, uint64_t (&arr)[MAX_READ_LEN]) {
    // prep
    if (seqlen < window_size) {
        return 0;
    } else if ((seqlen - window_size) > MAX_READ_LEN) {
        return 0;
    }
    int num_added=0;
    
    // first window_size
    uint64_t bit2f=0;
    int nn=0;
    for (int i=0; i < window_size; i++) {
        bit2f <<= 2;
        bit2f |= dna_to_2bitf_64[seq[i]];
        if (seq[i] == 'N' || seq[i] == 'n') {  // ignore when N or n appears
            nn= window_size - 1;
        } else if (nn > 0) {  // within window_size-nt from N or n
            nn--;
        }
    }
    if (nn == 0) {
        arr[num_added]=bit2f;
        num_added++;
    }
    
    // rolling calc.
    for (ull i=window_size; i < seqlen; i++) {
        bit2f <<= 2;
        bit2f |= dna_to_2bitf_64[seq[i]];
        if (seq[i] == 'N' || seq[i] == 'n') {  // ignore when N or n appears
            nn= window_size - 1;
        } else if (nn > 0) {  // within window_size-nt from N or n
            nn--;
        } else {
            arr[num_added]=bit2f;
            num_added++;
        }
    }
    return num_added;
}


/*
 This is the de facto main func.
 Args:
    1) input .mk file generated by `save_redundant_kmers`
    2) input .mi file generated by `save_redundant_kmers`
    3) input fasta file. This fasta must contain one line of sequence per one fasta header.
    4) output fasta file. If the file already exists, this overwrites it.
 */
int remove_multimapping(char* in_mk, char* in_mi, char* in_fa, char* out_fa) {
    // prepare infile
    std::ifstream infile;
    std::string line;
    
    // load redundant k-mer number
    infile.open(in_mi);
    if (! infile.is_open()) { return 1; }
    if (! getline(infile, line)) { return 1; }
    ull num_kmer=std::stoull(line);
    infile.close();
    std::cout << "Number of k-mers loading from " << in_mk << ": " << num_kmer << std::endl;
    
    // load .mk
    infile.open(in_mk, std::ios::binary);
    if (! infile.is_open()) { return 1; }
    std::vector<uint64_t> blacklist;
    blacklist.resize(num_kmer);
    infile.read((char*)&blacklist[0], sizeof(ull) * num_kmer);
    infile.close();
    const std::vector<uint64_t>& cblacklist=blacklist;
    
    // for 2bit conversion
    const int window_size=init_dna_to_2bit_64();
    
    // read fa, judge multimapping or not
    infile.open(in_fa);
    if (! infile.is_open()) { return 1; }
    std::ofstream outfile;
    outfile.open(out_fa);
    if (! outfile.is_open()) { return 1; }
    
    std::string header;
    uint64_t arr[MAX_READ_LEN]={0};
    int num_in_arr=0;
    ull pos=0;
    int n=0;
    ull removed=0;
    while (std::getline(infile, line)) {
        if (line[0] == FASTA_HEADER_START) {
            header=line;
        } else {
            // convert to 2bit
            ull seqlen=line.size();
            num_in_arr=dna_to_2bit_monodirectional_64(line.c_str(), seqlen, window_size, arr);
            n=0;
            for (int i=0; i < num_in_arr; i++) {
                pos=custom_binary_search(cblacklist, num_kmer, arr[i]);
                if (cblacklist[pos] == arr[i]) {
                    n++;
                }
            }
            if (n == num_in_arr) {
                removed++;
            } else {
                outfile << header << '\n' << line << '\n';
            }
        }
    }
    std::cout << "Number of sequence removed: " << removed << std::endl;
    return 0;
}


/*
 Just a file existence checker
 */
bool file_checker(char* f_path) {
    std::FILE* infile=fopen(f_path, "r");
    if (! infile) { return 1; }
    fclose(infile);
    return 0;
}


/*
 This is just an wrapper of remove_multimapping().
 Args:
    1) input_prefix that is the same name as the output_prefix specified when running `save_redundant_kmers`
    2) input fasta file name
    3) output fasta file name
 Usage:
    ./prog input_prefix input.fa output.fa
 */
int main(int argc, char* argv[]) {
    // argv check
    if (argc <= 3) {
        std::cerr << "Please specify input prefix, input fasta, and output fasta names." << std::endl;
        return 1;
    } else if (argc >= 5) {
        std::cerr << "Too many arguments. Please specify input prefix, input fasta, and output fasta names." << std::endl;
        return 1;
    }
    
    // summarize paths
    std::string in_prefix=std::string(argv[1]);
    std::string str_mk= in_prefix + ".mk";
    std::string str_mi= in_prefix + ".mi";
    char* in_mk=(char *)str_mk.c_str();
    char* in_mi=(char *)str_mi.c_str();
    char* in_fa=argv[2];
    char* out_fa=argv[3];
        
    // file check
    assert(file_checker(in_mk) == 0);
    assert(file_checker(in_mi) == 0);
    assert(file_checker(in_fa) == 0);
    std::ofstream outfile;
    outfile.open(out_fa);
    if (! outfile.is_open()) { return 1; }
    outfile.close();
    
    std::cout << ".mk: " << in_mk << std::endl;
    std::cout << ".mi: " << in_mi << std::endl;
    std::cout << "in.fa: " << in_fa << std::endl;
    std::cout << "out.fa: " << out_fa << std::endl;
    
    // process find_and_save_red_kmers()
    int ret=remove_multimapping(in_mk, in_mi, in_fa, out_fa);
    
    return ret;
}



